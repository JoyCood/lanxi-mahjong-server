package algo

import (
	"strconv"
	"testing"
)

// 测试
func TestExist(t *testing.T) {
	cards := []byte{0x07, 0x08, 0x09, 0x18, 0x18, 0x41,0x43,0x44}
	value := existHu(cards)
	t.Log(cards, value, strconv.FormatInt(int64(value), 2))
	cs4 := []byte{0x08, 0x08, 0x18, 0x18, 0x18, 0x41,0x41,0x41, 0x41}
	var ok bool = existFour2(cs4)
	t.Log("ok -> ", ok)
	//cs3 := []byte{0x01, 0x05, 0x09, 0x11, 0x15, 0x19, 0x21, 0x25, 0x29,0x41,0x43,0x51,0x52,0x53}
	//cs3 := []byte{0x01, 0x05, 0x09, 0x11, 0x19, 0x21, 0x29,0x41,0x42,0x43,0x44,0x51,0x52,0x53}
	cs3 := []byte{0x01,0x05,0x09,0x11,0x15,0x18,0x21,0x25,0x29,0x41,0x42,0x43,0x52,0x53}
	var thirteen uint32 = existThirteen(cs3)
	t.Log("thirteen -> ", thirteen)
	//cs7 := []byte{0x01, 0x01, 0x02, 0x02, 0x11, 0x11, 0x19,0x19,0x21,0x21,0x44,0x44,0x52,0x52}
	cs7 := []byte{0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x19,0x19,0x21,0x21,0x44,0x44,0x52,0x52}
	var seven uint32 = exist7pair(cs7)
	t.Log("seven -> ", seven)
	cs7kong := []byte{0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x21,0x21,0x21,0x21,0x44,0x44,0x44,0x44}
	var haveKong int = haveKong(cs7kong)
	t.Log("haveKong -> ", haveKong)
}

// 大七对, 4刻子+2, 不可以吃/清一色/字一色
// 有序slices cs 包含吃，碰，杠
func TestHuTypeDetect(t *testing.T) {
	//大七对
	//cs := []byte{0x01, 0x01, 0x01, 0x11, 0x11, 0x11, 0x21, 0x21, 0x21,0x44,0x44, 0x51, 0x51, 0x51}
	//清一色
	//cs := []byte{0x01, 0x02, 0x03, 0x04, 0x04, 0x04,0x05,0x05,0x05,0x06,0x07,0x08,0x09,0x09}
	//字一色
	//cs := []byte{0x41, 0x41, 0x42, 0x42, 0x43, 0x43, 0x44, 0x44, 0x51,0x51,0x51,0x52,0x52,0x52}
	//cs := []byte{0x11,0x11,0x11,0x11,0x24,0x24,0x24,0x44,0x44,0x44,0x07,0x07,0x14,0x14,0x14}
	//cs := []byte{0x01,0x02,0x03,0x04, 0x14,0x15,0x16, 0x27,0x27,0x27,0x41,0x41,0x41}
	//cs := []byte{0x16,0x17,0x18,0x24,0x24,0x26,0x27,0x28,0x42,0x43,0x44,0x51,0x52,0x53}
	//cs := []byte{0x01,0x01,0x04,0x04,0x04,0x14,0x15,0x16,0x25,0x25,0x25,0x17,0x17,0x17}
	//cs := []byte{0x11,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x07,0x08,0x09,0x41,0x43,0x44}
	//cs := []byte{0x03,0x03,0x03,0x03,0x05,0x05,0x22,0x22,0x24,0x24,0x15,0x15,0x53,0x53}
	cs := []byte{0x51,0x52,0x53,0x51,0x52,0x53,0x51,0x52,0x53,0x51,0x52,0x53,0x54,0x54}
	var val uint32 = HuTypeDetect(false, false, true, cs)
	t.Log("val -> ", val)
}

// 测试
func TestNextSeat(t *testing.T) {
	t.Log("NextSeat -> ", NextSeat(1))
	t.Log("NextSeat -> ", NextSeat(2))
	t.Log("NextSeat -> ", NextSeat(3))
	t.Log("NextSeat -> ", NextSeat(4))
}

// 测试
func TestRemove(t *testing.T) {
	cs2chow := []byte{0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x21,0x21,0x21,0x21,0x44,0x44,0x44,0x44}
	cs2chow = Remove(0x21, cs2chow)
	t.Log("cs2chow -> ", cs2chow, " len -> ", len(cs2chow))
	cs2chow = Remove(0x11, cs2chow)
	t.Log("cs2chow -> ", cs2chow, " len -> ", len(cs2chow))
	cs2chow = Remove(0x44, cs2chow)
	t.Log("cs2chow -> ", cs2chow, " len -> ", len(cs2chow))
}

// 测试
func TestCode(t *testing.T) {
	//c2 := byte(5460561 >> 8 & 0xFF)
	//t.Log("c2 -> ", c2)
	//card := EncodeChow(0x23,0x24,0x25)
	//t.Logf("card -> %d ", card)
	//var card uint32 = 1381651
	//var card uint32 = 21073
	//var card uint32 = 5396
	var card uint32 = 1382680
	c1, c2, c3 := DecodeChow(card)
	t.Log("c1, c2, c3 -> ", c1, c2, c3)
	//c1, c2 := DecodeChow2(card)
	//t.Log("c1, c2 -> ", c1, c2)
	//var card2 uint32 = 1447444
	//var card2 uint32 = (22 << 8) | 20
	var card2 uint32 = 5652
	t.Logf("card2 -> %d ", card2)
	c21, c22 := DecodeChow2(card2)
	t.Log("c1, c2 -> ", c21, c22)
}

// 测试胡牌
func Test_hu(t *testing.T) {
	//cards := []byte{0x02,0x03,0x04,0x26,0x26,0x41,0x42,0x42,0x43,0x44,0x26}
	//cards := []byte{0x07, 0x08, 0x09, 0x18, 0x18, 0x41,0x43,0x44}
	cards := []byte{0x26,0x26,0x41,0x42,0x42,0x43,0x44,0x44}
	value := existHu(cards)
	t.Log(cards, value, strconv.FormatInt(int64(value), 2))
	//value = existHu3n(cards, len(cards))
	//t.Logf("%x, %d, %v\n", cards, value, strconv.FormatInt(int64(value), 2))
	ok := Exist(0x18, cards, 3)
	t.Log("ok -> ", ok)
	cs, st := RemoveE(0x18, cards, 3)
	t.Log("cs -> ", cs, " st -> ", st)
	s, c := DecodePeng(0x413)
	t.Logf("s %d, c %x", s, c)
	//cards2 := []byte{0x41,0x42,0x42,0x43,0x44,0x44}
	//v2 := existHu3n2_zi(cards2, len(cards2))
	//t.Log(v2)
}

// 测试胡牌
func TestMask(t *testing.T) {
	var v uint32 = 0x20100c0 // 0x100c0
	//胡牌方式
	if v&QIANG_GANG > 0 {
		t.Log("QIANG_GANG -> ", v)
	}
	if v&HU_KONG_FLOWER > 0 {
		t.Log("HU_KONG_FLOWER -> ", v)
	}
	if v&HU_MENQING > 0 {
		t.Log("HU_MENQING -> ", v)
	}
	if v&HU_DANDIAO > 0 {
		t.Log("HU_DANDIAO -> ", v)
	}
	if v&TIAN_HU > 0 {
		t.Log("TIAN_HU -> ", v)
	}
	if v&DI_HU > 0 {
		t.Log("DI_HU -> ", v)
	}
	//牌型
	if v&HU_PING > 0 {
		t.Log("HU_PING -> ", v)
	}
	if v&HU_SINGLE > 0 {
		t.Log("HU_SINGLE -> ", v)
	}
	if v&HU_SINGLE_ZI > 0 {
		t.Log("HU_SINGLE_ZI -> ", v)
	}
	if v&HU_SEVEN_PAIR_BIG > 0 {
		t.Log("HU_SEVEN_PAIR_BIG -> ", v)
	}
	if v&HU_SEVEN_PAIR > 0 {
		t.Log("HU_SEVEN_PAIR -> ", v)
	}
	if v&HU_SEVEN_PAIR_KONG > 0 {
		t.Log("HU_SEVEN_PAIR_KONG -> ", v)
	}
	if v&HU_ONE_SUIT > 0 {
		t.Log("HU_ONE_SUIT -> ", v)
	}
	if v&HU_ALL_ZI > 0 {
		t.Log("HU_ALL_ZI -> ", v)
	}
	//胡
	if v&PAOHU > 0 {
		t.Log("PAOHU -> ", v)
	}
	if v&ZIMO > 0 {
		t.Log("ZIMO -> ", v)
	}
	//操作
	if v&HU > 0 {
		t.Log("HU -> ", v)
	}
	if v&PENG > 0 {
		t.Log("PENG -> ", v)
	}
	if v&MING_KONG > 0 {
		t.Log("MING_KONG -> ", v)
	}
	if v&AN_KONG > 0 {
		t.Log("AN_KONG -> ", v)
	}
	if v&BU_KONG > 0 {
		t.Log("BU_KONG -> ", v)
	}
	if v&KONG > 0 {
		t.Log("KONG -> ", v)
	}
	if v&CHOW > 0 {
		t.Log("CHOW -> ", v)
	}
	t.Log("v -> ", v)
	//胡牌方式
}

// 测试胡牌
func Test_zuhe(t *testing.T) {
	//b := []int{1,2,3,4,5}
	//t.Log(zuheResult(len(b), 3))
	//ms := map[int]int{0:1,1:2,2:1,3:2}
	ms := []int{2,2,2,2,1}
	ok := existHu3n_zi(ms, ms)
	t.Log(ok)
	//ms := []int{1,2,1,2}
	//ms[1] -= 1
	//t.Log(ms)
	mss := map[int]int{0:1,1:2,2:1,3:2}
	cs := mss
	delete(cs, 0)
	t.Log(cs, mss)
	list1 := []int{1,2,1,1,1}
	list2 := make([]int, len(list1)-1)
	copy(list2, append(list1[:1], list1[2:]...))
	list2[1] = 100
	t.Log(list1)
	t.Log(list2)
	t.Log(existHu3n2_zi(list1))
	t.Log(existHu3n2_zi(list2))
	mcc := map[byte]int{0x41:1,0x42:2,0x43:1,0x44:2}
	mv := map2s(mcc)
	t.Log(mv)
	//cards := []byte{0x01,0x02,0x03,0x23,0x24,0x25,0x26,0x26,0x41,0x42,0x42,0x43,0x44,0x44} //数做将,字顺子
	//cards := []byte{0x01,0x02,0x03,0x23,0x24,0x25,0x26,0x26,0x42,0x42,0x42,0x44,0x44,0x44} //数做将,字刻子
	//cards := []byte{0x01,0x02,0x03,0x23,0x24,0x25,0x41,0x41,0x41,0x43,0x44} //字做将,刻子折做将
	cards := []byte{0x01,0x02,0x03,0x23,0x24,0x25,0x41,0x41,0x41,0x41,0x42,0x42,0x44,0x44} //字做将,杠折做将
	v := existHu(cards)
	t.Log(v)
}
